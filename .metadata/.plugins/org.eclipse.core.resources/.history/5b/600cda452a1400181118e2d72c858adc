/*----------------------------------------------------------------------------*/
/* Copyright (c) 2017-2018 FIRST. All Rights Reserved.                        */
/* Open Source Software - may be modified and shared by FRC teams. The code   */
/* must be accompanied by the FIRST BSD license file in the root directory of */
/* the project.                                                               */
/*----------------------------------------------------------------------------*/

package org.usfirst.frc.team3495.robot;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.IMotorController;
import com.ctre.phoenix.motorcontrol.RemoteFeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;

import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.buttons.JoystickButton;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.interfaces.Gyro;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.SPI.Port;
import edu.wpi.first.wpilibj.command.Subsystem;
/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the build.properties file in the
 * project.
 */




public class Robot extends IterativeRobot {
	private static final String kDefaultAuto = "Default";
	private static final String kCustomAuto = "My Auto";
	private String m_autoSelected;
	private SendableChooser<String> m_chooser = new SendableChooser<>();
	TalonSRX t0 = new TalonSRX(0);
	TalonSRX t1 = new TalonSRX(1);
	TalonSRX t2 = new TalonSRX(2);
	TalonSRX t3 = new TalonSRX(3);
	TalonSRX armLeft = new TalonSRX(4);
	TalonSRX armRight = new TalonSRX(5);
	TalonSRX climber = new TalonSRX(6);
	TalonSRX intake = new TalonSRX(7);

	ADXRS450_Gyro gyro = new ADXRS450_Gyro();
	double angle = gyro.getAngle();
	double rate = gyro.getAngle();

	Joystick left = new Joystick(2);
	Joystick right = new Joystick(0);
	Joystick controller = new Joystick(1);
	double YValue = controller.getRawAxis(1);

	JoystickButton climb = new JoystickButton (controller, 5);
	JoystickButton climbLift = new JoystickButton (right, 1);
	JoystickButton intakeForward = new JoystickButton(right, 2);
	JoystickButton intakeReverse = new JoystickButton(left, 2);
	//double value = armStick.getRawAxis(1);
	JoystickButton armlift = new JoystickButton(controller, 9);
	

	int Distanceinticks = (t1.getSensorCollection().getQuadraturePosition());
	int Distanceinrotations = (t1.getSensorCollection().getQuadraturePosition()/4096);

	int Distanceinticks2 = (t3.getSensorCollection().getQuadraturePosition());
	int Distanceinrotationst3 = (t3.getSensorCollection().getQuadraturePosition()/4096);
	double Distanceininches = (t1.getSensorCollection().getQuadraturePosition());
	double Distanceininchest3 = (t3.getSensorCollection().getQuadraturePosition()*18.85/-4096);
	int leftmotorV = t1.getSensorCollection().getPulseWidthVelocity();
	int rightmotorV = t3.getSensorCollection().getPulseWidthVelocity();

	double currentEncoder1Value = t1.getSensorCollection().getQuadratureVelocity();

	int encoder1Sum = 0;
	int encoder1Last = 0;      // Encoder value from the last tick
	int encoder3Sum = 0;
	int encoder3Last = 0;
	
	Compressor c = new Compressor(0);
	
	int encoder1SumGodAuton2 = 0;
	int encoder1LastGodAuton2 = 0;      // Encoder value from the last tick for god auton 2
	int encoder3SumGodAuton2 = 0;
	int encoder3LastGodAuton2 = 0;
	
	int encoder1SumGodAuton3 = 0;
	int encoder1LastGodAuton3 = 0;      // Encoder value from the last tick for god auton 2
	int encoder3SumGodAuton3 = 0;
	int encoder3LastGodAuton3 = 0;

	public interface PidInput{
	}

	double Setpoint, Input, Output;
	double ITerm, lastInput;
	double kp, ki, kd;
	

	
	int SampleTime = 1000; // 1sec
	double outMin, outMax;
	boolean inAuto = false;
	

	int P_ON_M = 0;
	int P_ON_E = 1;
	boolean pOnE = true;
	double initInput;

	
	int P, I, D = 1;
	int integral, previous_error, setpoint = 0;
	
	
	
	double kP;
	double kI;
	double kD;
	double kF;
	
	
	double tolerance;
	double settlingTime;
	PidInput pidInput;

	boolean absSetPoint= false;
	boolean noOscillation = false;
	//double minTarget = 0.0;
	//double maxTarget = 0.0;
	//double minOutput = -1.0;
	//double maxOutput =1.0;


	double prevTime = 0.0;
	double currError = 0.0;
	double totalError = 0.0;
	double settlingStartTime = 0.0;
	double setPoint = 0.0;
	double setPointSign = 1.0;
	
	double errSum, lastErr;
	double input = 0.0;
	double output = 0.0;

	double pTerm;
	double iTerm;
	double dTerm;
	double fTerm;
	double CompressorValue = c.getCompressorCurrent();

	boolean running = true;
	boolean runningBehind = true;
	boolean runningStraight = true;
	boolean runningLeftRight = true;
	boolean scaleReached = false;
	boolean exchangeReached = false;
	
	
	// most of these are for god auton
	boolean partOneComplete = false;
	boolean partTwoComplete = false;
	boolean partTwoMain = false;
	boolean partThreeComplete = false;
	boolean partFourComplete = false;
	boolean partFiveComplete = false;
	boolean halfwayDone = false;
	boolean turnComplete = false;
	boolean partTwo = false;
	boolean newBlock = false;
	boolean running2 = true;
	boolean BlockPickUp = false;
	boolean running3 = true;
	boolean SwitchDrop = false;

	
	int DIRECT = 0;
	double rcw;
	
	
	/**
	 * This function is run when the robot is first started up and should be
	 * used for any initialization code.
	 */
	@Override
	public void robotInit() {
		m_chooser.addDefault("Default Auto", kDefaultAuto);
		m_chooser.addObject("My Auto", kCustomAuto);
		SmartDashboard.putData("Auto choices", m_chooser);


		t1.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, 10);
		t3.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, 0, 10);
		t1.setSelectedSensorPosition(0, 0, 0);
		t3.setSelectedSensorPosition(0, 0, 0);


		//dashboard = HalDashboard.getInstance();
		//this.instanceName = instanceName;
		this.kP = Math.abs(kP);
		this.kI = Math.abs(kI);
		this.kD = Math.abs(kD);
		this.kF = Math.abs(kF);
		//this.tolerance = Math.abs(tolerance;
		//this.settlingTime = Math.abs(settinglingTime);
		//this.pidInput = pidInput;

		//put other encoder here

		//t1.setSensorPhase(true);
		//put others here


		//t1.setSelectedSensorPosition(t1.getSensorCollection().getPulseWidthPosition() & 0xFFF, 0, 10);
		//t1.setSelectedSensorPosition(0, 0, 10);
		//t3.setSelectedSensorPosition(0, 0, 10);
		//t1.setSensorPhase(false);
		//t1.setInverted(false);
		//t1.setInverted(true);

		//t1.configPeakOutputForward(.4, 10);
		//	t2.configPeakOutputForward(.4, 10);
		//	t3.configPeakOutputForward(.4, 10);
		//	t0.configPeakOutputForward(.4, 10);

		//	t1.configPeakOutputReverse(-.4, 10);
		//	t2.configPeakOutputReverse(-.4, 10);
		//	t3.configPeakOutputReverse(-.4, 10);
		//	t0.configPeakOutputReverse(-.4, 10);


	}


	/**
	 * This autonomous (along with the chooser code above) shows how to select
	 * between different autonomous modes using the dashboard. The sendable
	 * chooser code works with the Java SmartDashboard. If you prefer the
	 * LabVIEW Dashboard, remove all of the chooser code and uncomment the
	 * getString line to get the auto name from the text box below the Gyro
	 *
	 * <p>You can add additional auto modes by adding additional comparisons to
	 * the switch structure below with additional strings. If using the
	 * SendableChooser make sure to add them to the chooser code above as well.
	 */



	protected void initDefaultCommand() {

	}

	@Override

	public void autonomousInit() {

		m_autoSelected = m_chooser.getSelected();
		/*autoSelected = SmartDashboard.getString("Auto Selector", 
		defaultAuto);*/
		System.out.println("Auto selected: " + m_autoSelected);
		t1.getSensorCollection().setQuadraturePosition(0, 10);
		t3.getSensorCollection().setQuadraturePosition(0, 10);
		t1.getSensorCollection().setPulseWidthPosition(0, 10);
		t3.getSensorCollection().setPulseWidthPosition(0, 10);
		//t1.set(ControlMode.Position, 0);
		//t3.set(ControlMode.Position, 0);
		t1.set(ControlMode.PercentOutput, 0);
		t3.set(ControlMode.PercentOutput, 0);
		t1.setSelectedSensorPosition(0, 0, 0);
		t3.setSelectedSensorPosition(0, 0, 0);
		t1.config_kP(0, 0, 10);
		t1.config_kI(0,0.2,10);
		t1.config_kD(0,0,10);

		//calibrate();

		//auton2();
		int encoder1Value = -t1.getSensorCollection().getQuadratureVelocity();
		int encoder3Value = t3.getSensorCollection().getQuadratureVelocity();
		encoder1Sum += encoder1Value - encoder1Last;
		encoder1Sum += encoder1Value;
		encoder3Sum += encoder3Value - encoder3Last;
		encoder3Sum += encoder3Value;

		System.out.println("Vel left: " + encoder1Value + "  last left: " + encoder1Last + "  encoder1Sum: " + encoder1Sum);
		System.out.println("Vel right: " + encoder3Value + "  last right: " + encoder3Last + "  encoder3Sum: " + encoder3Sum);
		System.out.println("Ratio: " + (encoder1Sum / (double) encoder3Sum));
		System.out.println("Position: " + -t1.getSelectedSensorPosition(0));

		encoder1Last = encoder1Value;
		encoder3Last = encoder3Value;

	}
	
	public void setSetpoint (int setpoint) {
		this.setpoint = setpoint;
	}
	
	public void armPID() {
		
		double error = setpoint - /*mag encoder, switch to amt soon*/t1.getSelectedSensorPosition(0); 
		this.integral += (error *.2);
		double derivitave = (error - this.previous_error) / .02;
		this.rcw = P*error + I*this.integral + D*derivitave; 
		
	}
	

	/**
	 * This function is called periodically during autonomous.
	 */
	@Override
	public void autonomousPeriodic() {
		if(c.getCompressorCurrent() <= 8){
			c.setClosedLoopControl(true);
		}else{
			c.setClosedLoopControl(false);
		}
		System.out.println("COMPRESSOR:" + c.getCompressorCurrent());
		switch (m_autoSelected) {
		case kCustomAuto:
			// Put custom auto code here
			break;
		case kDefaultAuto:
		default:
			//System.out.println(t1.getSensorCollection().getQuadratureVelocity());
			//System.out.println(t3.getSensorCollection().getQuadratureVelocity());
			//double Distanceininches = (t1.getSensorCollection().getQuadraturePosition()*18.85/-4096);
			//double Distanceininchest3 = (t3.getSelectedSensorPosition(0)*18.85/4096);
			//System.out.println(Distanceininches);
			//System.out.println(Distanceininchest3);
			//System.out.println(angle);
 
 
			
			//			System.out.println(encoder1Value - encoder1Last);
			/*
			int encoder1Value = -t1.getSensorCollection().getQuadratureVelocity();
			int encoder3Value = t3.getSensorCollection().getQuadratureVelocity();
			encoder1Sum += encoder1Value - encoder1Last;
			encoder1Sum += encoder1Value;
			encoder3Sum += encoder3Value - encoder3Last;
			encoder3Sum += encoder3Value;

			double angle = gyro.getAngle();
			double rate = gyro.getRate();
			
			encoder1Last = encoder1Value;
			encoder3Last = encoder3Value;

			
			if(partOneComplete == false) {
				GodAuton();
			}
			
			
			if (partOneComplete == true) {
				GodAuton2(); 
			} 
			
			if (partTwoComplete == true && partOneComplete == true) {
				GodCode3();
			}
			
			if(partThreeComplete == true && partTwoComplete == true && partOneComplete == true) {
				GodMode4();
			}
			
			//auton3();

			//PUT ALL DRIVE CODE IN PERIODIC getSensorCollection().getPulseWidthPosition()

*/
		}

	}


	// If getPulseWidthPosition() = your whatever distance wanted, do another action by setting the drive to turn to an encoder position

	/**
	 * This function is called periodically during operator control.
	 */
	@Override
	public void teleopInit() {

		t1.setSelectedSensorPosition(0, 0, 0);
		t3.setSelectedSensorPosition(0, 0, 0);
		t1.set(ControlMode.PercentOutput, 0);
		t3.set(ControlMode.PercentOutput, 0); 
		
	}
	public void teleopPeriodic() {

		double angle = gyro.getAngle();
		tankDrive(left.getY(), right.getY()); 

		if (angle >= 360) {
			gyro.reset();
		}

		if (angle <= -360) {
			gyro.reset(); 

		}

		climber();

		intake();
		
		

		int encoder1Position= t1.getSensorCollection().getQuadratureVelocity();
		int encoderGoal = t1.getSelectedSensorPosition(21729);
		int error = encoderGoal - encoder1Position;
		int error_prior = 0;
		int integral = 0;
		int derivative = (error-error_prior) / 10;
		int sleepTime = 10;


		kP = 0;
		kI = 0.1;
		kD = 0;


		//gyro.calibrate();
		//gyro.reset();

		//System.out.println(t1.getSensorCollection().getQuadraturePosition());
		//System.out.println(Distanceininchest3);
		System.out.println(angle);
		//System.out.println(t1.getSensorCollection().getQuadratureVelocity());
		System.out.println("Output: " + output);
		System.out.println("Position: " + t1.getSelectedSensorPosition(0));
		System.out.println("Error: " + error);

		//Code that allows the climber to raise and pull the robot up the rung
	}
	


	/**
	 * This function is called periodically during test mode.
	 */
	@Override
	public void testPeriodic() {

	}
	public void tankDrive(double left, double right){
		t1.set(ControlMode.PercentOutput, left);
		t0.set(ControlMode.Follower, 1);
		t3.set(ControlMode.PercentOutput, -right);
		t2.set(ControlMode.Follower, 3);
	}

	void climber(){
		if(climb.get()) {
			climber.set(ControlMode.PercentOutput, 1);	
		}else{
			climber.set(ControlMode.PercentOutput, 0);	
		}
	}

	void driveStraight() {
		int encoder1Value = -t1.getSensorCollection().getQuadratureVelocity();
		int encoder3Value = t3.getSensorCollection().getQuadratureVelocity();
		encoder1Sum += encoder1Value - encoder1Last;
		encoder1Sum += encoder1Value;
		encoder3Sum += encoder3Value - encoder3Last;
		encoder3Sum += encoder3Value;

		System.out.println("Vel left: " + encoder1Value + "  last left: " + encoder1Last + "  encoder1Sum: " + encoder1Sum);
		System.out.println("Vel right: " + encoder3Value + "  last right: " + encoder3Last + "  encoder3Sum: " + encoder3Sum);
		System.out.println("Ratio: " + (encoder1Sum / (double) encoder3Sum));

		encoder1Last = encoder1Value;
		encoder3Last = encoder3Value;
		//t1.configMotionAcceleration(400, 10); //400 per second (DONT USE!!!!!!)
		//t1.configMotionCruiseVelocity(400, 10); //drive at 400 (DONT USE!!!!!), just a test	4`


	}

	void intake(){
		if(intakeForward.get()){
			intake.set(ControlMode.PercentOutput, 1);
		}else if(intakeReverse.get()){
			intake.set(ControlMode.PercentOutput, -1);
		}else{
			intake.set(ControlMode.PercentOutput, 0);
		}
	}

	 void arm(){
		
		 //t1.configMotionAcceleration(1, 10);
		 //t1.configMotionCruiseVelocity(1, 10);
		 
		 if(armlift.get()){
			armLeft.set(ControlMode.PercentOutput, 0.03);
			armRight.set(ControlMode.PercentOutput, -0.03);
		}else{
			armLeft.set(ControlMode.PercentOutput, 0);
			armRight.set(ControlMode.PercentOutput, 0);
		}

	}
	/*void auton(){
		//t1.getSelectedSensorPosition(5);
		//t3.getSelectedSensorPosition(5);
		//t1.setSelectedSensorPosition(FeedbackDevice, 5, 5);
		//t3.setSelectedSensorPosition(FeedbackDevice, 5, 5);\
		tankDrive(.40, .40);
		Timer.delay(3);
		tankDrive(0, 0);
		Timer.delay(2);
		tankDrive(.25, .25);
		Timer.delay(2);
		tankDrive(0, 0);
		Timer.delay(10);
	} 
	 */


	void auton2() { 
		if(t1.getSelectedSensorPosition(0) > -20000) {
			tankDrive(.25, .25);
		}else if (t1.getSelectedSensorPosition(0) <= -20000 /*Type.Input*/){
			tankDrive(.32,0);
			Timer.delay(2.1);
			tankDrive(.25,.25);
			Timer.delay(2.5);
			tankDrive(0, 0);
			Timer.delay(30);

		}
	}

	void auton3() {
		//(gyro.getAngle()<90){
		if (t1.getSelectedSensorPosition(0) >t3.getSelectedSensorPosition(0));
		tankDrive(.257,.25);
		Timer.delay(6);
		tankDrive(0,0);
	}

	void auton4(){
		if(angle > 0){
			tankDrive(.3, .25);
		}
		else if(angle < 0){
			tankDrive(.25, .3);
		}
	}




	void auton5() {
		/*
		 * For each talon (x2)
		 * 	collect each encoder value at every tick and stock in an ArrayList<Integer>.
		 * 
		 * For every tick
		 * 	collect the sum of differences in the encoders
		 * 
		 * Correct path based on the differences between the sum of differences
		 */
		//		encoder1List.add(t1.getSensorCollection().getQuadratureVelocity());
		//		encoder1List.get(0);
		//		encoder1List.get(encoder1List.size() - 1);


		int encoder1Value = -t1.getSensorCollection().getQuadratureVelocity();
		int encoder3Value = t3.getSensorCollection().getQuadratureVelocity();
		encoder1Sum += encoder1Value - encoder1Last;
		encoder1Sum += encoder1Value;
		encoder3Sum += encoder3Value - encoder3Last;
		encoder3Sum += encoder3Value;

		System.out.println("Vel left: " + encoder1Value + "  last left: " + encoder1Last + "  encoder1Sum: " + encoder1Sum);
		System.out.println("Vel right: " + encoder3Value + "  last right: " + encoder3Last + "  encoder3Sum: " + encoder3Sum);
		System.out.println("Ratio: " + (encoder1Sum / (double) encoder3Sum));



		encoder1Last = encoder1Value;
		encoder3Last = encoder3Value;
		System.out.println(t1.getSelectedSensorPosition(0));
	}

	//		tankDrive(.25, .25);
	/*if(t1.getSensorCollection().getQuadratureVelocity() > t3.getSensorCollection().getQuadratureVelocity()) {
			tankDrive(.25, .275);
		}else if (t1.getSensorCollection().getQuadratureVelocity() < t3.getSensorCollection().getQuadratureVelocity()) {
			tankDrive(.27, .25);
	 */

	/*
		if(encoder1Sum > encoder3Sum) {
			tankDrive(.24,.27);
		}else if(encoder1Sum < encoder3Sum) {
			tankDrive(.27, .24);

		}else{
			tankDrive(.25, .25);
		}
	}
	 */


	void auton6(){
		//gyro.reset();

		double angle = gyro.getAngle();
		double rate = gyro.getRate();

		int encoder1Value = -t1.getSensorCollection().getQuadratureVelocity();
		int encoder3Value = t3.getSensorCollection().getQuadratureVelocity();

		//int encoderRatio = encoder1Sum/encoder3Sum;
		encoder1Sum += encoder1Value - encoder1Last;
		encoder1Sum += encoder1Value;
		encoder3Sum += encoder3Value - encoder3Last;
		encoder3Sum += encoder3Value;

		System.out.println("Vel left: " + encoder1Value + "  last left: " + encoder1Last + "  encoder1Sum: " + encoder1Sum);
		System.out.println("Vel right: " + encoder3Value + "  last right: " + encoder3Last + "  encoder3Sum: " + encoder3Sum);
		System.out.println("Angle: " + angle);
		System.out.println("Position: " + t1.getSelectedSensorPosition(0));
		encoder1Last = encoder1Value;
		encoder3Last = encoder3Value;

		if(encoder1Sum > encoder3Sum && t1.getSelectedSensorPosition(0) < 500) {
			tankDrive(.24,.27);
			if(-t1.getSelectedSensorPosition(0) > 20000 && angle < 45){
				System.out.println("Angle: " + angle);
				tankDrive(0,0);
				Timer.delay(2);
				System.out.println("Angle: " + angle);
				tankDrive(.35,.0);
				Timer.delay(1); 
				tankDrive(0,0);
			}
		}else if(encoder1Sum < encoder3Sum && t1.getSelectedSensorPosition(0) < 500) {
			tankDrive(.27, .24);
		}else if (encoder1Sum == encoder3Sum){
			tankDrive(.25,.25);
		}else{
			tankDrive(0,0);

			//217.29 ticks per inch
			//2,607.48 ticks per feet

		}
	}

	void autonStraightLine() {

		int encoder1Value = -t1.getSensorCollection().getQuadratureVelocity();
		int encoder3Value = t3.getSensorCollection().getQuadratureVelocity();
		encoder1Sum += encoder1Value - encoder1Last;
		encoder1Sum += encoder1Value;
		encoder3Sum += encoder3Value - encoder3Last;
		encoder3Sum += encoder3Value;

		double angle = gyro.getAngle();
		double rate = gyro.getRate();

		System.out.println("Vel left: " + encoder1Value + "  last left: " + encoder1Last + "  encoder1Sum: " + encoder1Sum);
		System.out.println("Vel right: " + encoder3Value + "  last right: " + encoder3Last + "  encoder3Sum: " + encoder3Sum);
		System.out.println("Ratio: " + (encoder1Sum / (double) encoder3Sum));
		System.out.println("Position: " + -t1.getSelectedSensorPosition(0));
		System.out.println("Angle: " + angle);
		encoder1Last = encoder1Value;
		encoder3Last = encoder3Value;


		if(encoder1Sum  > encoder3Sum && running == true) {
			tankDrive(.24,.27);

		}else if(encoder1Sum < encoder3Sum && running == true) {
			tankDrive(.27, .24);
		}else if(encoder1Sum == encoder3Sum && running == true) {
			tankDrive(.25, .25);
		}else if(encoder1Sum > encoder3Sum && running == false) {
			tankDrive(0,0);
		}else if(encoder1Sum < encoder3Sum && running == false) {
			tankDrive(0,0);
		}else if(encoder1Sum == encoder3Sum && running == false) {
			tankDrive(0,0);
		}



		if (-t1.getSelectedSensorPosition(0) >= 31174) { //Crossing the auton line
			running = false;
		}
		if (running == false && angle < 85) {
			tankDrive(.35, 0);
		}else if(angle >= 85) {
			tankDrive(0,0);
			Timer.delay(1);
			tankDrive(0,0);
		}
	}


	
	void autonEDUCATION(){
		/*DO THE AUTON A CODE (the one that goes to the switch straight in front)
		 * 
		 * 
		 * copy the varaibles here
		 copy the self correct code here (NOT THE tankDrive(0,0))
		 set the quadsensor pos to 0 here, timeout to 10
		 do a simple if(t1 position >= X)
		 	then tankDrive(0,0)
		 do a drive to angle function here
		 then stop at the X angle
		 time.delay(.3)
		 then a simple if(t1 position >= X)
		 	then tankDrive(0,0)

		 *PID HERE
		 */
		int encoder1Position= t1.getSensorCollection().getQuadratureVelocity();
		int encoderGoal = t1.getSelectedSensorPosition(21729);
		int error = encoderGoal - encoder1Position;
		int error_prior = 0;
		int integral = 0;
		int derivative = (error-error_prior) / 10;
		int sleepTime = 10;


		kP = 0;
		kI = 0.1;
		kD = 0;


		/*while(encoder1Position < encoderGoal) {
			error = encoderGoal - encoder1Position;
			integral = integral + (error * 10);
			output = kP * error + kI * integral * kD * derivative;
			error_prior = error;
		}*/


		//Thread.sleep(sleepTime);
		//Imaginary encoder values for arm, resting = 0, low = 2000 medium = 4000 and tall = 6000
	}


	public void setPID(double p, double i, double d) {

	}

	void autonrightback(){ 
		int encoder1Value = -t1.getSensorCollection().getQuadratureVelocity();
		int encoder3Value = t3.getSensorCollection().getQuadratureVelocity();
		double angle = gyro.getAngle();
		double rate = gyro.getAngle();
		encoder1Sum += encoder1Value - encoder1Last;
		encoder1Sum += encoder1Value;
		encoder3Sum += encoder3Value - encoder3Last;
		encoder3Sum += encoder3Value;

		System.out.println("Vel left: " + encoder1Value + "  last left: " + encoder1Last + "  encoder1Sum: " + encoder1Sum);
		System.out.println("Vel right: " + encoder3Value + "  last right: " + encoder3Last + "  encoder3Sum: " + encoder3Sum);
		System.out.println("Ratio: " + (encoder1Sum / (double) encoder3Sum));
		System.out.println("Position: " + -t1.getSelectedSensorPosition(0));
		System.out.println("Angle: " + gyro.getAngle());
		System.out.println(runningStraight);
		encoder1Last = encoder1Value;
		encoder3Last = encoder3Value;



		if(encoder1Sum > encoder3Sum && runningStraight == true){
			tankDrive(.24, .27);
		}else if(encoder1Sum < encoder3Sum && runningStraight == true){
			tankDrive(.27, .24);
		}else if(encoder1Sum == encoder3Sum && runningStraight == true) {
			tankDrive(.25, .25);
		}

		if (-t1.getSelectedSensorPosition(0) >= 52990.70 && angle > -80 && runningStraight == true) { //Crossing the auton line
			tankDrive(0, .35);
			Timer.delay(1);


		}

		if (-t1.getSelectedSensorPosition(0) >= 70000 && angle < -80) { //Crossing the switch line
			runningStraight = false;
		}

		if (runningStraight == false) {
			tankDrive(0,0);
		}


		if(angle >= 360) {
			gyro.reset();
		}

		if (angle < -360) {
			gyro.reset();
		}
	}

	void straightRightLeft(){


		int encoder1Value = -t1.getSensorCollection().getQuadratureVelocity();
		int encoder3Value = t3.getSensorCollection().getQuadratureVelocity();
		encoder1Sum += encoder1Value - encoder1Last;
		encoder1Sum += encoder1Value;
		encoder3Sum += encoder3Value - encoder3Last;
		encoder3Sum += encoder3Value;

		System.out.println("Vel left: " + encoder1Value + "  last left: " + encoder1Last + "  encoder1Sum: " + encoder1Sum);
		System.out.println("Vel right: " + encoder3Value + "  last right: " + encoder3Last + "  encoder3Sum: " + encoder3Sum);
		System.out.println("Ratio: " + (encoder1Sum / (double) encoder3Sum));
		System.out.println("Position: " + -t1.getSelectedSensorPosition(0));
		System.out.println("Angle: " + gyro.getAngle());
		System.out.println(runningStraight);
		encoder1Last = encoder1Value;
		encoder3Last = encoder3Value;

		double angle = gyro.getAngle();


		runningStraight = true;


		//if (angle >)


		if(encoder1Sum > encoder3Sum && runningStraight == true){ 
			tankDrive(.24, .27);
		}else if(encoder1Sum < encoder3Sum && runningStraight == true){
			tankDrive(.27, .24);
		}else if(encoder1Sum == encoder3Sum && runningStraight == true) { 
			tankDrive(.25, .25);
		}



	}

	void scaleAuton() {

		int encoder1Value = -t1.getSensorCollection().getQuadratureVelocity();
		int encoder3Value = t3.getSensorCollection().getQuadratureVelocity();
		encoder1Sum += encoder1Value - encoder1Last;
		encoder1Sum += encoder1Value;
		encoder3Sum += encoder3Value - encoder3Last;
		encoder3Sum += encoder3Value;

		System.out.println("Vel left: " + encoder1Value + "  last left: " + encoder1Last + "  encoder1Sum: " + encoder1Sum);
		System.out.println("Vel right: " + encoder3Value + "  last right: " + encoder3Last + "  encoder3Sum: " + encoder3Sum);
		System.out.println("Ratio: " + (encoder1Sum / (double) encoder3Sum));
		System.out.println("Position: " + -t1.getSelectedSensorPosition(0));
		System.out.println("Angle: " + gyro.getAngle());
		encoder1Last = encoder1Value;
		encoder3Last = encoder3Value;

		/*copy the varaibles here
			 copy the self correct code here (NOT THE tankDrive(0,0))
			 set the quadsensor pos to 0 here, timeout to 10
			 do a simple if(t1 position >= X)
			 	then tankDrive(0,0)
			 do a drive to angle function here
			 then stop at the X angle
			 time.delay(.3)
			 then a simple if(t1 position >= X)
			 	then tankDrive(0,0) */


		double angle = gyro.getAngle();
		scaleReached = false;



		if(encoder1Sum > encoder3Sum && scaleReached == false){ 
			tankDrive(.24, .27);
		}else if(encoder1Sum < encoder3Sum && scaleReached == false) {
			tankDrive(.27, .24);
		}else if(encoder1Sum == encoder3Sum && scaleReached == false) {
			tankDrive(.25, .25);
		}

		if(-t1.getSelectedSensorPosition(0) >= 30000 && scaleReached == false) {
			scaleReached = true;
		}

		if (-t1.getSelectedSensorPosition(0) >= 30000 && angle < 75  && scaleReached == true) {
			tankDrive(.35, 0);
		}else if(angle >= 75 && scaleReached == true) {
			tankDrive(-.25, -.25);  
			Timer.delay(2);
			tankDrive(.25, .25);
			Timer.delay(2);
			tankDrive(0, 0);
			Timer.delay(5);
		}

	} 


	/*
			if(t1.getSelectedSensorPosition(0) >= 500 && angle < 90){
				tankDrive(0,0);
				Timer.delay(2);
				tankDrive(.50,.0);
			}else if(t1.getSelectedSensorPosition(0)>= 500 && angle >= 90){
				tankDrive(0, 0);
	 */

	/*
			if(t1.getSelectedSensorPosition(0) >= 500 && angle < 90){
				tankDrive(.50,.0);
			}else if(t1.getSelectedSensorPosition(0)>= 500 && angle >= 90){
				tankDrive(0, 0);
			}else{
				tankDrive(.25, .25);   
	 */
	//}
	//if(t1.getSelectedSensorPosition(0) >= 2607 & angle < 90){
	//tankDrive(.0,.50);
	//}
	//if(t1.getSelectedSensorPosition(0) >= 2607 & angle >= 90){
	//tankDrive(0, 0);
	/*

		System.out.println("Angle:" + angle);
		System.out.println("Rate" + rate);

		if (angle >= 360) {
			gyro.reset();
		}

		if (angle <= -360) {
			gyro.reset(); 

		}

		if(t1.getSelectedSensorPosition(0) >= 2607 & angle < 90){
			tankDrive(.0,.50);
		}
		if(t1.getSelectedSensorPosition(0) >= 2607 & angle >= 90){
			tankDrive(0, 0);
	 */



	void calibrate() {
		gyro.calibrate();
	}

	void autonLeftRight(){

		int encoder1Value = -t1.getSensorCollection().getQuadratureVelocity();
		int encoder3Value = t3.getSensorCollection().getQuadratureVelocity();
		encoder1Sum += encoder1Value - encoder1Last;
		encoder1Sum += encoder1Value;
		encoder3Sum += encoder3Value - encoder3Last;
		encoder3Sum += encoder3Value;

		double angle = gyro.getAngle();
		double rate = gyro.getRate();


		System.out.println("Vel left: " + encoder1Value + "  last left: " + encoder1Last + "  encoder1Sum: " + encoder1Sum);
		System.out.println("Vel right: " + encoder3Value + "  last right: " + encoder3Last + "  encoder3Sum: " + encoder3Sum);
		System.out.println("Ratio: " + (encoder1Sum / (double) encoder3Sum));
		System.out.println("Position: " + -t1.getSelectedSensorPosition(0));
		System.out.println("Angle: " + gyro.getAngle());
		encoder1Last = encoder1Value;
		encoder3Last = encoder3Value;

		if(encoder1Sum > encoder3Sum){ 
			tankDrive(.24, .27);
		}else if(encoder1Sum < encoder3Sum){
			tankDrive(.27, .24);
		}else if(encoder1Sum == encoder3Sum) {
			tankDrive(.25, .25);
		}

		if (-t1.getSelectedSensorPosition(0) >= 15251.896) { //Crossing the switch line
			runningLeftRight = false;
		}
		
		if (runningLeftRight == false && angle < 85) {
			tankDrive(.35, 0);
		}else if(angle >= 85){
			autonStraightLine();
		}
	}





	void autonExchange(){
		
		double angle = gyro.getAngle();
		
		int encoder1Value = -t1.getSensorCollection().getQuadratureVelocity();
		int encoder3Value = t3.getSensorCollection().getQuadratureVelocity();
		encoder1Sum += encoder1Value - encoder1Last;
		encoder1Sum += encoder1Value;
		encoder3Sum += encoder3Value - encoder3Last;
		encoder3Sum += encoder3Value;

		System.out.println("Vel left: " + encoder1Value + "  last left: " + encoder1Last + "  encoder1Sum: " + encoder1Sum);
		System.out.println("Vel right: " + encoder3Value + "  last right: " + encoder3Last + "  encoder3Sum: " + encoder3Sum);
		System.out.println("Ratio: " + (encoder1Sum / (double) encoder3Sum));
		System.out.println("Position: " + -t1.getSelectedSensorPosition(0));
		System.out.println("Exchange Reached: " + exchangeReached);
		System.out.println("Angle: " + gyro.getAngle());
		System.out.println("Half Done: " + halfwayDone);
		System.out.println("Exchange Reached: " + exchangeReached);
		System.out.println("Turn Complete: " + turnComplete);
		System.out.println("New Block: " + newBlock);
		

		encoder1Last = encoder1Value;
		encoder3Last = encoder3Value;
		

		if (encoder1Sum > encoder3Sum && exchangeReached == false && halfwayDone == false && newBlock == false) {
			tankDrive(.24, .27);
		}else if(encoder1Sum < encoder3Sum && exchangeReached == false && halfwayDone == false && newBlock == false){
			tankDrive(.27, .24);
		}else if(encoder1Sum == encoder3Sum && exchangeReached == false && halfwayDone == false && newBlock == false ){
			tankDrive(.25, .25);
		}

		if(-t1.getSelectedSensorPosition(0) >= 15251.896 && exchangeReached == false){
			exchangeReached = true; 
		}
 

		if(-t1.getSelectedSensorPosition(0) >= 20000 && angle < 75 && exchangeReached == true && halfwayDone == false && newBlock == false){
			tankDrive(.35, 0);
		}else if(angle >= 75 && exchangeReached == true && halfwayDone == false){
			tankDrive(-.25, -.25);
			//intake.set(ControlMode.PercentOutput, -1); (add when we use the actual robot cause the practice one is dummy stupid)
			Timer.delay(2);
			tankDrive(.25, .25);
			Timer.delay(1);
			halfwayDone = true;
			
		}
		 
		if(halfwayDone == true && angle < 170 && -t1.getSelectedSensorPosition(0) >= 20000 && turnComplete == false) {
			tankDrive(.35, 0);
		}else if(halfwayDone == true && angle >= 170 && -t1.getSelectedSensorPosition(0) < 50000 && turnComplete == false) {
			tankDrive(.25, .25);
			partTwo = true;
			turnComplete = true;
		}

		/*if (encoder1Sum > encoder3Sum && exchangeReached == true && halfwayDone == true && turnComplete == true && partTwo == false){
			tankDrive(.24, .27);
		}else if(encoder1Sum < encoder3Sum && exchangeReached == true && halfwayDone == true && turnComplete == true && partTwo == false){
			tankDrive(.27, .24);
		}else if(encoder1Sum == encoder3Sum && exchangeReached == true && halfwayDone == true && turnComplete == true && partTwo == false){
			tankDrive(.25, .25);
		}
		 */
		
		
		if(gyro.getAngle() > 360) {
			gyro.reset(); 
		}else if (gyro.getAngle() < -360) {
			gyro.reset();
		}
		 
		if(partTwo = true && angle <= 250 && newBlock == false && exchangeReached == true && turnComplete == true && -t1.getSelectedSensorPosition(0) >= 40000) {
			tankDrive(.35, 0);
			Timer.delay(1);
		}else if(partTwo = true && angle >= 250 && newBlock == false && exchangeReached == true && turnComplete == true) {
			tankDrive(.10, .10);
			Timer.delay(2);
			//insert intake code here (picking up a new block)
			tankDrive(-.10, -.10);
			tankDrive(0, -.35);
			newBlock = true; 
			     
		}else if (partTwo = true && angle > 250 && newBlock == true && exchangeReached == true && turnComplete == true){
			tankDrive(0, 0);
			//Inset angle of portal here
		}
		 
		 
	}

 
	
	
	// This is some PID code
	void SetTunings(double Kp, double Ki, double Kd, int pOn){
			kp = Kp;
			ki = Ki;
			kd = Kd;
			
			}
		
	
	
	void GodAuton() { //This auton code will out a preset block on the switch, grab one from the back of the switch, and carry on to the scale where they will add another block, go back to the start, pick up a block and put it in the exchange
	//Part 1
		int encoder1Value = -t1.getSensorCollection().getQuadratureVelocity();
		int encoder3Value = t3.getSensorCollection().getQuadratureVelocity();
		encoder1Sum += encoder1Value - encoder1Last;
		encoder1Sum += encoder1Value;
		encoder3Sum += encoder3Value - encoder3Last;
		encoder3Sum += encoder3Value;

		double angle = gyro.getAngle();
		double rate = gyro.getRate();

		System.out.println("Vel left: " + encoder1Value + "  last left: " + encoder1Last + "  encoder1Sum: " + encoder1Sum);
		System.out.println("Vel right: " + encoder3Value + "  last right: " + encoder3Last + "  encoder3Sum: " + encoder3Sum);
		System.out.println("Ratio: " + (encoder1Sum / (double) encoder3Sum));
		System.out.println("Position: " + -t1.getSelectedSensorPosition(0));
		System.out.println("Angle: " + angle);
		System.out.println("Part Two Main: "  + partTwoMain);
		encoder1Last = encoder1Value;
		encoder3Last = encoder3Value;


		if(encoder1Sum  > encoder3Sum && running == true && partOneComplete == false) {
			tankDrive(.24,.27);
		}else if(encoder1Sum < encoder3Sum && running == true && partOneComplete == false) {
			tankDrive(.27, .24);
		}else if(encoder1Sum == encoder3Sum && running == true && partOneComplete == false) {
			tankDrive(.25, .25);
		}
		
		
		if (-t1.getSelectedSensorPosition(0) >= 31174 && partOneComplete == false) { //Crossing the auton line
			running = false;
		}
		
		if (running == false && angle < 85 && partOneComplete == false && SwitchDrop == false) {
			tankDrive(.35, 0);
		}else if(angle >= 85 && partOneComplete == false && running == false && SwitchDrop == false) {
			tankDrive(.10,.10);
			//insert arm code here, raising, shooting than lowering
			Timer.delay(1);
			tankDrive(-.10, -.10);
			Timer.delay(1);
			SwitchDrop = true;
		} 
		
		if(partOneComplete == false && angle >= 70 && partTwoComplete == false && SwitchDrop == true) {
			tankDrive(-.35, 0);
		}else if(partOneComplete == false && angle < 15 && partTwoComplete == false && SwitchDrop == true) {
			partOneComplete = true;
		}
		  
		

	}
	
	void GodAuton2() {
		//Part 2
		int encoder1ValueGodAuton2 = -t1.getSensorCollection().getQuadratureVelocity();
		int encoder3ValueGodAuton2 = t3.getSensorCollection().getQuadratureVelocity();
		encoder1SumGodAuton2 += encoder1ValueGodAuton2 - encoder1LastGodAuton2;
		encoder1SumGodAuton2 += encoder1ValueGodAuton2;
		encoder3SumGodAuton2 += encoder3ValueGodAuton2 - encoder3LastGodAuton2;
		encoder3SumGodAuton2 += encoder3ValueGodAuton2;

		double angle = gyro.getAngle();
		double rate = gyro.getRate(); 

		System.out.println("Vel left: " + encoder1ValueGodAuton2 + "  last left: " + encoder1LastGodAuton2 + "  encoder1SumGodAuton2: " + encoder1SumGodAuton2);
		System.out.println("Vel right: " + encoder3ValueGodAuton2 + "  last right: " + encoder3LastGodAuton2 + "  encoder3SumGodAuton2: " + encoder3SumGodAuton2);
		System.out.println("Ratio: " + (encoder1SumGodAuton2 / (double) encoder3SumGodAuton2));
		System.out.println("Position: " + -t1.getSelectedSensorPosition(0));
		System.out.println("Angle: " + angle);
		System.out.println("Part One Complete: "  + partOneComplete);
		System.out.println("Part 2 Complete: "  + partTwoComplete);
		System.out.println("Part Two Main: "  + partTwoMain);
		System.out.println("Running: " + running2);
		System.out.println("Block Pick Up: " + BlockPickUp);
		encoder1Last = encoder1ValueGodAuton2;
		encoder3Last = encoder3ValueGodAuton2;
		
		if(encoder1SumGodAuton2  > encoder3SumGodAuton2 && partTwoComplete == false && running2 == true) {
			tankDrive(.24,.27);
		}else if(encoder1SumGodAuton2 < encoder3SumGodAuton2 && partTwoComplete == false && running2 == true) {
			tankDrive(.27, .24);
		}else if(encoder1SumGodAuton2 == encoder3SumGodAuton2 && partTwoComplete == false && running2 == true) {
			tankDrive(.25, .25);
		}  
		
		
		if (-t1.getSelectedSensorPosition(0) >= 60000 && partTwoComplete == false  && running2 == true) {
			running2 = false;
		} 
	
		if(running2 == false && angle < 45 && -t1.getSelectedSensorPosition(0) >= 60000 && partTwoComplete == false && BlockPickUp == false && partThreeComplete == false) {
			tankDrive(.35, 0);
		}else if(angle >= 75 && -t1.getSelectedSensorPosition(0) > 60000 && partTwoComplete == false && running2 == false && BlockPickUp == false && partThreeComplete == false) {
			tankDrive(.10, .10);
			Timer.delay(2);
			intake.set(ControlMode.PercentOutput, 1);
			Timer.delay(1);
			intake.set(ControlMode.PercentOutput, 0);
			tankDrive(-.10, -.10);
			Timer.delay(2); 
			tankDrive(-.35,0);  
			BlockPickUp = true;
		}
		if(partTwoComplete == false && running2 == false && angle < 10 && BlockPickUp == true && partThreeComplete == false) {
			partTwoComplete = true;		
		}  
		 
	}
	
	void GodCode3() { //This also does the same thing as God auton 1, but a different part
		//Part 3
		
		int encoder1ValueGodAuton3 = -t1.getSensorCollection().getQuadratureVelocity();
		int encoder3ValueGodAuton3 = t3.getSensorCollection().getQuadratureVelocity();
		encoder1SumGodAuton3 += encoder1ValueGodAuton3 - encoder1LastGodAuton3;
		encoder1SumGodAuton3 += encoder1ValueGodAuton3;
		encoder3SumGodAuton3 += encoder3ValueGodAuton3 - encoder3LastGodAuton3;
		encoder3SumGodAuton3 += encoder3ValueGodAuton3;

		double angle = gyro.getAngle();
		double rate = gyro.getRate();

		System.out.println("Vel left: " + encoder1ValueGodAuton3 + "  last left: " + encoder1LastGodAuton3 + "  encoder1SumGodAuton3: " + encoder1SumGodAuton3);
		System.out.println("Vel right: " + encoder3ValueGodAuton3 + "  last right: " + encoder3LastGodAuton3 + "  encoder3SumGodAuton3: " + encoder3SumGodAuton3);
		System.out.println("Ratio: " + (encoder1SumGodAuton3 / (double) encoder3SumGodAuton3));
		System.out.println("Position: " + -t1.getSelectedSensorPosition(0));
		System.out.println("Angle: " + angle);
		System.out.println("Part Three Complete: " + partThreeComplete);
		encoder1Last = encoder1ValueGodAuton3;
		encoder3Last = encoder3ValueGodAuton3;
		
		partOneComplete = true;
		partTwoComplete = true;
	
		if(encoder1SumGodAuton3 > encoder3SumGodAuton3 && partThreeComplete == false && running3 == true && -t1.getSelectedSensorPosition(0) < 90000 && angle < 20 && running3 == true && partTwoComplete == true){
			tankDrive(.24, .27);
		}else if(encoder1SumGodAuton3 < encoder3SumGodAuton3 && partThreeComplete == false && running3 == true && -t1.getSelectedSensorPosition(0) < 90000 && angle < 20 && running3 == true && partTwoComplete == true){
			tankDrive(.27, .24); 
		}else if(encoder1SumGodAuton3 == encoder3SumGodAuton3 && partThreeComplete == false && running3 == true && -t1.getSelectedSensorPosition(0) < 90000 && angle < 20 && running == true && partTwoComplete == true){
			tankDrive(.25, .25);
		}
	
		if(angle < 20 && -t1.getSelectedSensorPosition(0) >= 90000 && partThreeComplete == false && running3 == true) {
			running3 = false;
		}
		
		if(angle < 20 && running3 == false && partThreeComplete == false) {
			tankDrive(.35, 0);
		}else if(angle >= 75 && -t1.getSelectedSensorPosition(0) > 90000 && partThreeComplete == false && running3 == false) {
			tankDrive(-.25, -.25);
			Timer.delay(2);
			tankDrive(.10, .10);
			//insert arm code here
			Timer.delay(2);
			tankDrive(-.25, -.25);
			Timer.delay(1);
		}
		/* 
		if(angle >= 170 && -t1.getSelectedSensorPosition(0) > 20000 && partThreeComplete == false) {
			tankDrive(.25, .25);
		}else if(angle > 85 && -t1.getSelectedSensorPosition(0) <= 20000 && partThreeComplete == false) {
			tankDrive(0, .35);
		}else if (angle <= 85 && -t1.getSelectedSensorPosition(0) <= 20000 && partThreeComplete == false) {
			tankDrive(.10, .10);
			intake.set(ControlMode.PercentOutput, 1);
			Timer.delay(2);
			intake.set(ControlMode.PercentOutput, 0);
			tankDrive(-.10, .10);
			Timer.delay(2);
			partThreeComplete = true;
		}
		*/
			
	
	}
	
	void GodMode4() {
		
	}
	
}
